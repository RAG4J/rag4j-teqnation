package org.rag4j;

import java.util.List;

import org.rag4j.indexing.IndexingService;
import org.rag4j.indexing.splitters.SentenceSplitter;
import org.rag4j.integrations.openai.OpenAIEmbedder;
import org.rag4j.integrations.openai.OpenAIFactory;
import org.rag4j.integrations.weaviate.WeaviateAccess;
import org.rag4j.integrations.weaviate.retrieval.WeaviateRetriever;
import org.rag4j.rag.embedding.Embedder;
import org.rag4j.rag.embedding.local.OnnxBertEmbedder;
import org.rag4j.rag.retrieval.Retriever;
import org.rag4j.rag.retrieval.quality.QuestionAnswerRecord;
import org.rag4j.rag.retrieval.quality.RetrievalQuality;
import org.rag4j.rag.retrieval.quality.RetrievalQualityService;
import org.rag4j.rag.store.local.InternalContentStore;
import org.rag4j.util.keyloader.KeyLoader;

/**
 * This is a bonus step that shows how to determine the quality of your RAG system. The quality is depending on
 *     the quality of all components. First we have the retriever that finds the relevant items for the question. The
 *     retriever strategy constructs the context. The generator is responsible for answering the question. If the generated
 *     answer is no answer to the question, the quality is low. If the generator creates a good answer to the question, we
 *     still need to verify if the answer is related to the context. If the answer is not related to the context, the
 *     quality is low. Therefore, we have three quality metrics:
 *     - Retrieval quality
 *     - Answer to question quality
 *     - Answer from context quality
 *
 *     In this step you explore all three quality metrics.
 */
public class AppStep4Bonus1Quality {

    private static final KeyLoader keyLoader = new KeyLoader();

    public static void main(String[] args) {

        /*************************
         *** Retrieval quality ***
         *************************/

//        Before you run the quality metrics for the receiver, you need to understand what we are doing. We have generated a
//        file with a question for each indexed chunk. The question is generated by the OpenAI question generator. Now, when
//        we ask the retriever the question we expect the retriever to find the correct chunk. If the retriever finds the
//        correct chunk, the quality is high. If the retriever finds the wrong chunk, the quality is low. The quality is
//        determined by the precision. The precision is the number of correct retrievals divided by the total number of
//        retrievals. The total number of retrievals is the total number of questions. The precision is a number between 0 and
//        1. The higher the number, the better the quality.

        Embedder embedder = new OnnxBertEmbedder();
        InternalContentStore contentStore = new InternalContentStore(embedder);
        IndexingService indexingService = new IndexingService(contentStore);
        indexingService.indexDocuments(new TeqnationContentReader(), new SentenceSplitter());

        RetrievalQualityService retrievalQualityService = new RetrievalQualityService(contentStore);
        List<QuestionAnswerRecord> questionAnswerRecords = retrievalQualityService.readQuestionAnswersFromFile("/data/teqnation/teqnation_questions_answers.csv");
        RetrievalQuality retrievalQuality = retrievalQualityService.obtainRetrievalQuality(questionAnswerRecords, embedder);

        System.out.println("Quality precision: " + retrievalQuality.getPrecision());
        System.out.println("Total questions: " + (retrievalQuality.getCorrect().size() + retrievalQuality.getIncorrect().size()));

        // TODO 1: Rewrite the embedder and the content store to use the OpenAIEmbedder and the WeaviateRetriever
        //  It is safe to skip if you have little time left. Did the quality improve? Why?
        // BEGIN SOLUTION

        // END
    }
}
